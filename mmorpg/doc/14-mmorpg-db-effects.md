# 14. MMORPG DB: Efectos

_27-09-2008_ _Juan Mellado_

Desde un punto de vista técnico, la solución más sencilla a priori para indicar si un personaje está vivo o muerto sería simplemente tener un atributo a nivel de personaje, indicando el estado en el que se encuentra. Sin embargo, a un personaje no suele afectarle sólo la muerte, sino que normalmente aplican sobre él una serie de efectos. O sea, las famosas pócimas, auras, bendiciones, maldiciones, dolencias, y demás parafernalia que cada juego concreto quiera implementar en su diseño. Dentro de ese mar de posibilidades, la muerte puede verse como una más de esas aflicciones que puede sufrir un personaje. Una aflicción un tanto especial quizás, pero una aflicción al fin al cabo, ya que la muerte de un personaje en este tipo de juegos no es algo permanente, sino que es un estado con carácter normalmente temporal, como suele serlo el resto. Debería ser vista más como un estado que tiene un efecto psicológico que afecta al jugador ("estoy muerto") que una excepción dentro de la lógica normal de procesamiento de los efectos aplicados sobre su personaje.

Un modelo normalizado que sea capaz de almacenar este tipo de efectos aplicables sobre un personaje puede ser bastante complejo de construir si se intenta diseñar para que prácticamente todo tenga cabida en él. Un diseñador imaginativo puede llegar a pensar en una gran cantidad de efectos muy distintos, que afecten a uno o muchos tipos de atributos distintos de los personajes, que tengan o no una duración determinada, y que posiblemente sólo puedan aplicarse a determinadas clases o razas. La clave del asunto para mi es ser capaz de sacar factor común y adoptar un compromiso de diseño. Establecer los atributos comunes que tienen todos los efectos, y hacer un ejercicio de abstracción sobre los casos especiales para conseguir que finalmente todos ellos puedan tratarse de una forma homogénea.

Puede ser una tarea bastante estéril diseñar un modelo extremadamente genérico, ya que luego las necesidades concretas del diseño de cada juego en particular pueden no tener cabida. Si me animara a hacer tal tipo de diseño, supongo que dentro de los atributos de la tabla de efectos incluiría un ID como clave primaria, un nombre (ID sobre la tabla de textos por idioma), una descripción (otro ID como el anterior) y algún que otro atributo básico, como la duración (tiempo), o alcance (distancia) del efecto, por ejemplo. El resto de parámetros asociados al efecto irían repartidos en una serie de tablas auxiliares de la forma acostumbrada. Por ejemplo, una tabla de relación con los atributos de los personajes afectados por el efecto, con columnas tales como el ID del efecto, el ID del tipo de atributo, y el valor concreto en que modifica el efecto al atributo (positivo o negativo, para indicar beneficio o daño respectivamente).

Si un juego en particular tuviera unas necesidades concretas acerca de que una serie de efectos, como por ejemplo que sólo puedan aplicarse a determinadas clases (o razas, o clases, o profesiones, o lo que se quiera), entonces debería existir una tabla de relación entre efectos y lo que se quiera. De igual forma, si un efecto se quisiera que tuviera un comportamiento periódico, como el de generar una determinada cantidad de merma en un atributo cada cierto tiempo, entonces habría que añadir una nueva columna en la tabla de relación entre efectos y atributos para almacenar el periodo de repetición (tiempo). Otras características propias de los efectos, como su tiempo de lanzamiento, tiempo de reutilización, número de veces que puede acumularse, etc, habría que ir estudiándolos uno a uno para ubicarlos correctamente. Incluso puede que algunos juegos necesiten relacionar unos efectos con otros, para señalar incompatibilidades por ejemplo.

Mientras que puede llegar a ser discutible la necesidad de tener almacenados en una base de datos todos los efectos disponibles en un juego, ya que siempre habrá quien opte por otras soluciones más "_hard-code_", lo que no parece tener discusión es la necesidad de guardar de forma persistente los efectos que afectan a un personaje. Es decir, no puede ocurrir que a un personaje tenga una serie de efectos en curso, se desconecte, vuelva a conectarse, y esos efectos ya no los tenga. Para conseguir este propósito, es claro que podría crearse una tabla de relación entre los personajes y los efectos que tiene aplicados en un momento concreto. Tabla que debería tener como mínimo un ID de personaje, un ID de efecto, y posiblemente algún tipo de indicador de carácter temporal que permita calcular el tiempo que resta del mismo, si aplica.

Otro aspecto importante de los efectos, aunque quizás no demasiado relacionado con su modelado mediante una base de datos, pero que siempre ha llamado mi atención, es el orden en que deben aplicarse. Por ejemplo, si un personaje tiene 5 puntos de salud, un hechizo dañino que le resta 10 puntos de salud cada 5 segundos, y un hechizo beneficioso que le suma 10 puntos de salud cada 5 segundos, entonces no puede ocurrir que el personaje muera por culpa del hechizo dañino. Supongo que esto puede resolverse aplicando siempre todos los efectos sobre los atributos del personaje y viendo los valores resultantes finales en vez de ir uno a uno. Es decir, no se puede aplicar el efecto dañino y decir que el personaje está muerto, hay que esperar a aplicar el efecto beneficioso también antes de decidir cambiar el estado del personaje. Y este es un ejemplo muy sencillo, la lógica de proceso puede llegar a complicarse bastante debido a las múltiples combinaciones que pueden darse.

En un marco más amplio, y cambiando un poco de tema, decir que siempre que se habla del estado en que puede encontrarse una entidad cualquiera, es habitual tener que hablar de diagramas de transición de estados. Es decir, los posibles estados en los que se puede estar, a que estados se pueden ir a partir de uno dado, y cuales son los motivos que provocan los cambios de estado. Por ejemplo, un personaje suele estar vivo hasta que agota toda su salud, momento en el que suele estar normalmente muerto. Tanto "vivo" como "muerto" serían los posibles estados, "morir" la transición entre la vida y la muerte, y "agotar salud" el motivo que genera la transición.

Modelar las reglas de este tipo de comportamientos puede hacerse de muchas formas, dependiendo principalmente la solución a adoptar de la flexibilidad deseada. Es decir, para un sistema en el que se prevean pocos cambios sobre la lógica de funcionamiento, implementar las reglas embebidas dentro del propio código fuente puede ser una solución bastante natural, totalmente válida, y posiblemente la más eficiente. Por el contrario, en un sistema donde las reglas quieran poder ampliarse o modificarse fácilmente, entonces una implementación basada en el uso de ficheros de datos externos, o algún lenguaje de _script_ interpretado, puede ser una mejor solución. Incluso es posible generar el código fuente a partir de una serie de reglas de producción descritas en ficheros, algo habitual dentro del mundillo de los intérpretes, compiladores y lenguajes de programación.

Almacenar los diagramas de transición de estados en una base de datos también puede hacerse, ya que bastaría con construir un modelo sencillo de tres tablas. Una primera tabla para los diagramas, una segunda para los posibles estados por diagrama, y otra para las transiciones (relaciones de unos estados con otros). El problema de esta solución suele ser que los desencadenantes de las transiciones y las correspondientes acciones que motivan suelen ser estar limitadas por el código fuente, ya que los procesos se implementan por código, no se tiene una visión de ellos como datos.
